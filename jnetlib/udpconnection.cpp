/*
** JNetLib
** Copyright (C) 2000-2001 Nullsoft, Inc.
** Author: Justin Frankel
** File: udpconnection.cpp - JNL UDP connection implementation
** License: see jnetlib.h
*/

#include "netinc.h"
#include "util.h"
#include "udpconnection.h"
#include <bfc/platform/minmax.h>
#include "../nu/strsafe.h"

JNL_UDPConnection::JNL_UDPConnection(unsigned short incoming_port, JNL_AsyncDNS *dns, int sendbufsize, int recvbufsize)
{
	init();
	open(dns, sendbufsize, recvbufsize);
	
  m_socket=::socket(PF_INET,SOCK_DGRAM,0);
  if (m_socket==-1)
  {
    m_errorstr="creating socket";
    m_state=STATE_ERROR;
  }
  SET_SOCK_BLOCK(m_socket,0);
	sockaddr_in m_iaddr;
  memset(&m_iaddr,0,sizeof(struct sockaddr_in));
  m_iaddr.sin_family=AF_INET;
  m_iaddr.sin_port=htons(incoming_port);
  m_iaddr.sin_addr.s_addr = htonl( INADDR_ANY );
  if(::bind(m_socket,(struct sockaddr *)&m_iaddr,sizeof(m_iaddr))==-1)
  {
    m_errorstr="binding socket";
    m_state=STATE_ERROR;
  }
  m_state=STATE_CONNECTED;

}

JNL_UDPConnection::JNL_UDPConnection()
{
	init();
}

void JNL_UDPConnection::init()
{
	m_errorstr="";
	address=0;
	address_len=0;
	m_dns=0;
	m_dns_owned=false;
	m_socket=-1;
	m_remote_port=0;
	m_state=STATE_NOCONNECTION;
	m_host[0]=0;
	saddr=0;
	m_last_addr_len=0;
	ttl=0;
}

void JNL_UDPConnection::set_ttl(uint8_t new_ttl)
{
	ttl=new_ttl;
	setsockopt(m_socket, IPPROTO_IP, IP_MULTICAST_TTL, (const char *)&ttl, sizeof(ttl));
}

void JNL_UDPConnection::open(int incoming_socket, api_dns *dns, size_t sendbufsize, size_t recvbufsize)
{
	if (dns != API_DNS_AUTODNS && dns)
	{
		m_dns=dns;
		m_dns_owned=false;
	}
	else if (!m_dns)
	{
		m_dns=new JNL_AsyncDNS;
		m_dns_owned=true;
	}
	recv_buffer.reserve(recvbufsize);
	send_buffer.reserve(sendbufsize);

	m_socket=incoming_socket;
	m_state=STATE_CONNECTED;

}

void JNL_UDPConnection::open(api_dns *dns, size_t sendbufsize, size_t recvbufsize)
{
	if (dns != API_DNS_AUTODNS && dns)
	{
		m_dns=dns;
		m_dns_owned=false;
	}
	else if (!m_dns)
	{
		m_dns=new JNL_AsyncDNS;
		m_dns_owned=true;
	}
	recv_buffer.reserve(recvbufsize);
	send_buffer.reserve(sendbufsize);
}


void JNL_UDPConnection::setpeer(char *hostname, int port)
{
	m_remote_port=(short)port;
	StringCbCopyA(m_host, sizeof(m_host), hostname);

	if (!m_host[0])
	{
		m_errorstr="empty hostname";
		m_state=STATE_ERROR;
	}
	else
	{
		m_state=STATE_RESOLVING;
	}
}

void JNL_UDPConnection::setpeer(sockaddr *addr, int length /* of addr */)
{
	//memcpy(&m_saddr, addr, sizeof(sockaddr));
	free(address);
	address_len=length;
	address=(sockaddr *)malloc(length);
	memcpy(address, addr, length);
}

JNL_UDPConnection::~JNL_UDPConnection()
{
	if (m_socket >= 0)
	{
		::shutdown(m_socket, SHUT_RDWR);
		::closesocket(m_socket);
		m_socket=-1;
	}
	if (!saddr) // free it if it was passed to us (by JNL_Listen, presumably)
		free(address); // TODO: change this if we ever do round-robin DNS connecting or in any way change how we handle 'address'

	if (m_dns_owned) 
	{
		delete static_cast<JNL_AsyncDNS *>(m_dns);
	}
}

void JNL_UDPConnection::run(int max_send_bytes, int max_recv_bytes, int *bytes_sent, int *bytes_rcvd)
{
	int bytes_allowed_to_send=(max_send_bytes<0)?send_buffer.size():max_send_bytes;
	int bytes_allowed_to_recv=(max_recv_bytes<0)?recv_buffer.avail():max_recv_bytes;

	if (bytes_sent) *bytes_sent=0;
	if (bytes_rcvd) *bytes_rcvd=0;	

	switch (m_state)
	{
	case STATE_RESOLVING:
		if (saddr == 0)
		{
			int a=m_dns->resolve(m_host, m_remote_port, &saddr, SOCK_DGRAM);
			if (!a) 
			{
					address=saddr->ai_addr;
					address_len=saddr->ai_addrlen;
				m_state=STATE_CONNECTED; 
			}
			else if (a == 1)
			{
				m_state=STATE_RESOLVING; 
				break;
			}
			else
			{
				m_errorstr="resolving hostname"; 
				m_state=STATE_ERROR; 
				return;
			}
		}
		break;
	case STATE_CONNECTED:
	case STATE_CLOSING:
		if (!send_buffer.empty() && bytes_allowed_to_send>0)
		{
			size_t sent = send_buffer.drain(this, bytes_allowed_to_send);
			if (bytes_sent)
			  *bytes_sent+=sent;
		}
					/* only read from socket when buffer is empty 
			 * otherwise we risk data loss
			 * see "man 2 recvfrom" for details
			 */
		if (recv_buffer.empty() && bytes_allowed_to_recv)
		{
			/*
			 * use LockBuffer()/UnlockBuffer() because
			 * "wrap-around" reads can't be done
			 * we might read data from two separate packets
			 */
				size_t len = MIN(recv_buffer.avail(), (size_t)bytes_allowed_to_recv);
			recv_buffer.clear();
				void *buffer = recv_buffer.LockBuffer();
				m_last_addr_len = sizeof(m_last_addr);
				int res=::recvfrom(m_socket,(char *)buffer,len,0,(sockaddr *)&m_last_addr,&m_last_addr_len);
				if (res == 0 || (res < 0 && ERRNO != EWOULDBLOCK))
				{ 
					recv_buffer.UnlockBuffer(0);
					m_state=STATE_CLOSED;
					break;
				}
				if (res > 0)
				{
					if (bytes_rcvd) 
						*bytes_rcvd+=res;
					recv_buffer.UnlockBuffer(res);
				}
				else
					recv_buffer.UnlockBuffer(0);

		}
		if (m_state == STATE_CLOSING)
		{
			if (send_buffer.empty()) m_state = STATE_CLOSED;
		}
		break;
	default: break;
	}
}

/* RingBuffer client function */
size_t JNL_UDPConnection::Read(void *dest, size_t len)
{
	if (!len)
		return 0;

	m_last_addr_len = sizeof(m_last_addr);
	int res=::recvfrom(m_socket, (char *)dest, len, 0, (sockaddr *)&m_last_addr, &m_last_addr_len);
	if (res == 0 || (res < 0 && ERRNO != EWOULDBLOCK))
	{        
		m_state=STATE_CLOSED;
		return 0;
	}
	if (res > 0)
		return res;
	else
		return 0;
}

/* RingBuffer client function */
size_t JNL_UDPConnection::Write(const void *dest, size_t len)
{
	if (!len)
		return 0;
	int res=::sendto(m_socket, (const char *)dest, len, 0, address, address_len);
	if (res==-1 && ERRNO != EWOULDBLOCK)
	{
		return 0;
		//              m_state=STATE_CLOSED;
	}
	if (res > 0)
		return res;
	else
		return 0;
}

void JNL_UDPConnection::close(int quick)
{
	if (quick || m_state == STATE_RESOLVING)
	{
		m_state=STATE_CLOSED;
		if (m_socket >= 0)
		{
			::shutdown(m_socket, SHUT_RDWR);
			::closesocket(m_socket);
		}
		m_socket=-1;
		recv_buffer.clear();
		send_buffer.clear();
		m_remote_port=0;
		m_host[0]=0;
		//memset(&m_saddr,0,sizeof(m_saddr));
	}
	else
	{
		if (m_state == STATE_CONNECTED) m_state=STATE_CLOSING;
	}
}

int JNL_UDPConnection::send_bytes_in_queue(void)
{
	return send_buffer.size();
}

int JNL_UDPConnection::send_bytes_available(void)
{
	return send_buffer.avail();
}

int JNL_UDPConnection::send(char *data, int length)
{
	if (length > send_bytes_available())
	{
		return -1;
	}

	send_buffer.write(data, length);
	return 0;
}

int JNL_UDPConnection::send_string(char *line)
{
	return send(line,strlen(line));
}

int JNL_UDPConnection::recv_bytes_available(void)
{
	return recv_buffer.size();
}

int JNL_UDPConnection::peek_bytes(char *data, int maxlength)
{
	size_t bytesPeeked = recv_buffer.peek(data, maxlength);
	return (int)bytesPeeked;
}

int JNL_UDPConnection::recv_bytes(char *data, int maxlength)
{
	size_t bytesRead = recv_buffer.read(data, maxlength);
	return (int)bytesRead;
}

int JNL_UDPConnection::recv_lines_available(void)
{
	int l=recv_bytes_available();
	int lcount=0;
	int lastch=0;
	int pos;
	for (pos=0; pos < l; pos ++)
	{
		char t;
		if (recv_buffer.at(pos, &t, 1) != 1)
			return lcount;
		if ((t=='\r' || t=='\n') &&(
			(lastch != '\r' && lastch != '\n') || lastch==t
			)) lcount++;
		lastch=t;
	}
	return lcount;
}

int JNL_UDPConnection::recv_line(char *line, int maxlength)
{
	if (maxlength > recv_buffer.size()) maxlength=recv_buffer.size();
	while (maxlength--)
	{
		char t;
		if (recv_buffer.read(&t, 1) == 0) 
		{
			*line=0;
			return 0;
		}
		if (t == '\r' || t == '\n')
		{
			char r;
			if (recv_buffer.peek(&r, 1) != 0)
			{
				if ((r == '\r' || r == '\n') && r != t)
					recv_buffer.advance(1);
			}
			*line=0;
			return 0;
			
		}
		*line++=t;
	}
	return 1;
}

int JNL_UDPConnection::get_interface(sockaddr *sin, socklen_t *sin_length)
{
	if (m_socket==-1) return 1;
	/*memset(sin,0,sizeof(sockaddr_storage));
	*sin_length =sizeof(sockaddr_storage);*/
	if (::getsockname(m_socket,(sockaddr *)sin,sin_length)) 
		return 1;
	return 0;
}

